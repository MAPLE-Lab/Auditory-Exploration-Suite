?seewave
?stft.ext
tuning_fork_A4.wav
"tuning_fork_A4.wav"
file="tuning_fork_A4.wav"
stft.ext(file="tuning_fork_A4.wav")
library(seewave)
library(tuneR)
a <- readWave("mysound.wav")
a <- readWave("tuning_fork_A4.wav")
getwd()
a <- readWave("Documents/tuning_fork_A4.wav")
a
stft.ext(file="Documents/tuning_fork_A4.wav")
?stft.ext
stft.ext(file="Documents/tuning_fork_A4.wav")
data(a)
a
savewav(waver, file="Documents/tuning_fork_A4.wav")
stft.ext("Documents/tuning_fork_A4.wav", db = TRUE)
stft.ext("Documents/tuning_fork_A4.wav", dB = TRUE)
b <- stft.ext("Documents/tuning_fork_A4.wav", db = TRUE)
b <- stft.ext("Documents/tuning_fork_A4.wav", dB = TRUE)
View(b)
c <- stft.ext("Documents/tuning_fork_A4.wav")
View(c)
View(c)
write.csv(c, file=waver.csv)
write.csv(spectra,file=c)
write.csv(c,file=wave.csv)
?write.csv
?stft
?stft.ext
fftw
?fftw
seedata(c)
seedata(c)
seedata(c)
View(c)
View(c)
?write.csv
write.csv(c, "c_data.csv")
frequency
f <- 44100
f/364
plotly
install.packages("plotly")
library("plotly", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library(plotly)
p <- plot_ly(midwest, x = ~percollege, color = ~state, type = "box")
p
library(plotly)
p <- plot_ly(midwest, x = ~percollege, color = ~state, type = "box")
p
?plotly
set.seed(100)
d <- diamonds[sample(nrow(diamonds), 1000), ]
plot_ly(d, x = ~carat, y = ~price, color = ~carat,
size = ~carat, text = ~paste("Clarity: ", clarity))
plot_ly(d, x = ~carat, y = ~price, color = ~carat, size = ~carat, text = ~paste("Clarity: ", clarity))
library("lazyeval")
plot_ly(d, x = ~carat, y = ~price, color = ~carat, size = ~carat, text = ~paste("Clarity: ", clarity))
detach("package:plotly", unload=TRUE)
library("plotly", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library("lazyeval")
library(plotly)
set.seed(100)
d <- diamonds[sample(nrow(diamonds), 1000), ]
plot_ly(d, x = ~carat, y = ~price, color = ~carat,
size = ~carat, text = ~paste("Clarity: ", clarity))
download.file("http://rug.mnhn.fr/seewave/WAV/E_chopardi_whistle.wav", destfile="cock.wav")
cock<-readWAve("cock.wav")
spectro3D(cock, f=22050, wl=490, ovlp=85, zp=6, maga=4, palette=spectro.colors)
rgl.viewpoint(-90,0)
step1 <- seq(-90,271,by=4)
for (i in step1){
rgl.viewpoint(i,(i/4.5)+30)
filename <- paste("picA",which(step1==i),".png",sep="")
rgl.snapshot(filename)
}
rgl.viewpoint(270,90)
step <- seq(270,-90,by=-4)
for (i in step2){
rgl.viewpoint(i,(i/4.5)+30)
filename <- paste("picB",which(step2==i),".png",sep="")
rgl.snapshot(filename)}
library("lazyeval")
library(plotly)
library(seewave)
download.file("http://rug.mnhn.fr/seewave/WAV/E_chopardi_whistle.wav", destfile="cock.wav")
cock<-readWAve("cock.wav")
spectro3D(cock, f=22050, wl=490, ovlp=85, zp=6, maga=4, palette=spectro.colors)
rgl.viewpoint(-90,0)
step1 <- seq(-90,271,by=4)
for (i in step1){
rgl.viewpoint(i,(i/4.5)+30)
filename <- paste("picA",which(step1==i),".png",sep="")
rgl.snapshot(filename)
}
rgl.viewpoint(270,90)
step <- seq(270,-90,by=-4)
for (i in step2){
rgl.viewpoint(i,(i/4.5)+30)
filename <- paste("picB",which(step2==i),".png",sep="")
rgl.snapshot(filename)}
download.file("http://rug.mnhn.fr/seewave/WAV/E_chopardi_whistle.wav", destfile="cock.wav")
cock<-readWAve("cock.wav")
?readWave
cock<-readWave("cock.wav")
ReadWave
library("tuneR", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
cock<-readWAve("cock.wav")
?readWave
readWave()
cock<-readWAve("cock.wav")
readWave("cock.wav")
cock <- readWAve("cock.wav")
cock<-readWave("cock.wav")
spectro3D(cock, f=22050, wl=490, ovlp=85, zp=6, maga=4, palette=spectro.colors)
spectro3D
?spectro3D
spectro3D(cock, f=22050, wl=490, ovlp=85, zp=6, maga=4, palette=spectro.colors)
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
?rgl
?"seewave"
?"seewave"
?"rgl"
??rgl
??rgl
install.packages("~/Downloads/rgl_0.98.1.tgz.cpgz", repos = NULL)
install.packages("~/Dropbox/local-SuperCollider/rgl_0.98.1.tgz", repos = NULL, type = .Platform$pkgType)
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
detach("package:rgl", unload=TRUE)
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
detach("package:rgl", unload=TRUE)
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
install.packages("rgl", lib="Desktop/rgl_0.96.0 (1).tgz")
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library(plotly)
dens <- with(diamonds, tapply(price, INDEX = cut, density))
data <- data.frame(
x = unlist(lapply(dens, "[[", "x")),
y = unlist(lapply(dens, "[[", "y")),
cut = rep(names(dens), each = length(dens[[1]]$x)))
p <- plot_ly(data, x = ~x, y = ~cut, z = ~y, type = 'scatter3d', mode = 'lines', color = ~cut)
p
View(data)
plot_ly()
plot_ly(x = 1:10, y = 1:10)
d <- diamonds[sample(nrow(diamonds), 1000), ]
plot_ly(d, x = ~carat, y = ~price, text = ~paste("Clarity: ", clarity),
mode = "markers", color = ~carat, size = ~carat, marker = list(line = list(color = "black")))
libPaths()
.libPaths()
library("plotly copy", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
detach("package:plotly copy", unload=TRUE)
library("plotly copy", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
detach("package:plotly copy", unload=TRUE)
library("plotly", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
detach("package:plotly", unload=TRUE)
library("plotly copy", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
version
samp.rate
soundfileActiveRead@samp.rate
filePath <- "~/Dropbox/MAPLE-Lab-Auditory-Exploration-Suite/programs/R"
frequencyResolution <- 4 # 4 is a good value with a frequency resolution of ~20Hz. 5 increases frequency resolution to ~10Hz.
thresholdValue <- 0.1 # Set at 0 all noise is captured; however, in top-down analysis (where the user selects the harmonics), this is not a problem and improves audio synthesis
# STEP 3 - SELECT SOUND
# Select the sound file to be analyzed
# Usage: Opens pop-up window for the user to select the sound file they want to analyze
# Input: WAVE/WAV file (i.e. .wav)
# Output: path to the sound file, saved as "soundfile" in R
soundfile <- file.choose()
setwd(filePath)
source("functions_R.R")
# STEP 1 - PACKAGES
# Loads required packages
loadPackages()
# STEP 2 - SET WORKING DIRECTORY
# CHANGE the 'filePath' value to the directory appropriate to your computer.
# All files in this program will be saved in the folder "R_working_files" within this directory.
# "R_working_files" is a directory pre-made in MAESTRO.
organizeDirectory(filePath)
# STEP 4 - STEREO CHECK
# Check if the sound file is stereo
# The later functions can only use mono sounds
# Therefore, if the sound is stereo, a message will appear and a new sound file will be generated saving only the LEFT channel
# Input: The soundfile path
# Output: If soundfile is mono, soundfileActive is the same file. If soundfile is stereo, a new WAVE file is generated, saved as soundfileMonoL.wav, to which soundActive is saved to.
soundfileStereoCheck(soundfile)
# STEP 5 - ANALYSIS PARAMETERS
# Here the resolution of ferquency in the analysis can be changed.
# The more frequency bins used, the greater the resolution.
# HOWEVER, the more frequency bins used, the less time bins used (i.e. worsened resolution in the time domain).
# 256*4 (1024) frequency bins appears to be a good number for general use.
# Input: In the line "numberOfFreqBins <- 256*4", change the multiplier (i.e. 4) to the desired amount.
# Output: wlValue will be used in following functions. freqBinWidth gives the frequency range of each bin.
freqParameters(frequencyResolution)
# Input: Nothing on the user's end. All values are generated from the previous functions.
# Output: soundfileDuration gives the duration of the sound file in seconds. timeBinWidth gives the width of each time bin in seconds. numberOfTimeBins gives the number of time bins that will be created by the software.
timeParameters(soundfileActiveRead)
# Input: The wlValue calculated previously and the active soundfile path (designated in STEP 4).
# Output: A visual overview of the time envelope and frequency spectrum of the soundfileActive.
acoustat(soundfileActiveRead, wl = wlValue)
# STEP 6 - EXTRACT FREQUENCYxTIME DATA
# The following function will create the data table that shows the changing intensity values of frequencies over time.
# Everything below the threshold value will be erased to reduce noise.
soundAnalysis(file=soundfileActive, wl = wlValue, thresholdValue = thresholdValue)
# STEP 7 - ISOLATE HARMONICS
# Top-down method: User selects number of harmonics and the fundamental
# Only the 16 (or specified) number of harmonics are required.
# Input: The numberOfHarmonics and the fundamentalFreq values.
# Outpit: A data table with only the rows of the desired harmonics.
numberOfHarmonics <- 16 # This value can be changed as necessary.
fundamentalFreq <- 261.63 # In Hz. (261.63 ~ middle C (C4))
isolateHarmonics() # Uses many arguments, so currently does not allow changes to arguments for simplicity of use
# Time Warning: This could take a minute or longer depending on the amount of data
# This creates all 16 harmonic arrays
#for(i in 1:numberOfHarmonics) {
#  temp_harmonicMatrixScaled_name = paste("harmonicMatrixScaled", i, "array", sep = ".")
#  temp_harmonicMatrixScaled_values <- paste(as.character(harmonicMatrixScaled[,i]), collapse=",")
#  assign(temp_harmonicMatrixScaled_name, temp_harmonicMatrixScaled_values)
#}
# STEP 8 - PLOT
# Time Warning: This could take a minute or longer depending on the amount of data
# Can only draw one at a time
zoom = 0.68 # 0.65 for printing
plotMAESTRO.2d(zoom=zoom)
plotMAESTRO.3d(zoom=zoom, view.x = -3.5, view.y = -1.5, view.z = 1.5, length.x = 1, length.y = 1, length.z = 1, showTime = TRUE, titleTime = "Time (s)") # Arguments control the 3D camera's angle
detach("package:rgl", unload=TRUE)
library("htmlwidgets", lib.loc="~/Library/R/3.2/library")
library("plotly", lib.loc="~/Library/R/3.2/library")
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
filePath <- "~/Dropbox/MAPLE-Lab-Auditory-Exploration-Suite/programs/R"
frequencyResolution <- 4 # 4 is a good value with a frequency resolution of ~20Hz. 5 increases frequency resolution to ~10Hz.
thresholdValue <- 0.1 # Set at 0 all noise is captured; however, in top-down analysis (where the user selects the harmonics), this is not a problem and improves audio synthesis
# STEP 3 - SELECT SOUND
# Select the sound file to be analyzed
# Usage: Opens pop-up window for the user to select the sound file they want to analyze
# Input: WAVE/WAV file (i.e. .wav)
# Output: path to the sound file, saved as "soundfile" in R
soundfile <- file.choose()
setwd(filePath)
source("functions_R.R")
# STEP 1 - PACKAGES
# Loads required packages
loadPackages()
# STEP 2 - SET WORKING DIRECTORY
# CHANGE the 'filePath' value to the directory appropriate to your computer.
# All files in this program will be saved in the folder "R_working_files" within this directory.
# "R_working_files" is a directory pre-made in MAESTRO.
organizeDirectory(filePath)
# STEP 4 - STEREO CHECK
# Check if the sound file is stereo
# The later functions can only use mono sounds
# Therefore, if the sound is stereo, a message will appear and a new sound file will be generated saving only the LEFT channel
# Input: The soundfile path
# Output: If soundfile is mono, soundfileActive is the same file. If soundfile is stereo, a new WAVE file is generated, saved as soundfileMonoL.wav, to which soundActive is saved to.
soundfileStereoCheck(soundfile)
# STEP 5 - ANALYSIS PARAMETERS
# Here the resolution of ferquency in the analysis can be changed.
# The more frequency bins used, the greater the resolution.
# HOWEVER, the more frequency bins used, the less time bins used (i.e. worsened resolution in the time domain).
# 256*4 (1024) frequency bins appears to be a good number for general use.
# Input: In the line "numberOfFreqBins <- 256*4", change the multiplier (i.e. 4) to the desired amount.
# Output: wlValue will be used in following functions. freqBinWidth gives the frequency range of each bin.
freqParameters(frequencyResolution)
# Input: Nothing on the user's end. All values are generated from the previous functions.
# Output: soundfileDuration gives the duration of the sound file in seconds. timeBinWidth gives the width of each time bin in seconds. numberOfTimeBins gives the number of time bins that will be created by the software.
timeParameters(soundfileActiveRead)
# Input: The wlValue calculated previously and the active soundfile path (designated in STEP 4).
# Output: A visual overview of the time envelope and frequency spectrum of the soundfileActive.
acoustat(soundfileActiveRead, wl = wlValue)
# STEP 6 - EXTRACT FREQUENCYxTIME DATA
# The following function will create the data table that shows the changing intensity values of frequencies over time.
# Everything below the threshold value will be erased to reduce noise.
soundAnalysis(file=soundfileActive, wl = wlValue, thresholdValue = thresholdValue)
# STEP 7 - ISOLATE HARMONICS
# Top-down method: User selects number of harmonics and the fundamental
# Only the 16 (or specified) number of harmonics are required.
# Input: The numberOfHarmonics and the fundamentalFreq values.
# Outpit: A data table with only the rows of the desired harmonics.
numberOfHarmonics <- 16 # This value can be changed as necessary.
fundamentalFreq <- 261.63 # In Hz. (261.63 ~ middle C (C4))
isolateHarmonics() # Uses many arguments, so currently does not allow changes to arguments for simplicity of use
# Time Warning: This could take a minute or longer depending on the amount of data
# This creates all 16 harmonic arrays
#for(i in 1:numberOfHarmonics) {
#  temp_harmonicMatrixScaled_name = paste("harmonicMatrixScaled", i, "array", sep = ".")
#  temp_harmonicMatrixScaled_values <- paste(as.character(harmonicMatrixScaled[,i]), collapse=",")
#  assign(temp_harmonicMatrixScaled_name, temp_harmonicMatrixScaled_values)
#}
# STEP 8 - PLOT
# Time Warning: This could take a minute or longer depending on the amount of data
# Can only draw one at a time
zoom = 0.68 # 0.65 for printing
plotMAESTRO.2d(zoom=zoom)
plotMAESTRO.3d(zoom=zoom, view.x = -3.5, view.y = -1.5, view.z = 1.5, length.x = 1, length.y = 1, length.z = 1, showTime = TRUE, titleTime = "Time (s)") # Arguments control the 3D camera's angle
soundfileActiveRead@samp.rate
soundfileActiveRead@samp.rate != 44100
soundfileActiveRead@samp.rate == 44100
filePath <- "~/Dropbox/MAPLE-Lab-Auditory-Exploration-Suite/programs/R"
frequencyResolution <- 4 # 4 is a good value with a frequency resolution of ~20Hz. 5 increases frequency resolution to ~10Hz.
thresholdValue <- 0.1 # Set at 0 all noise is captured; however, in top-down analysis (where the user selects the harmonics), this is not a problem and improves audio synthesis
# STEP 3 - SELECT SOUND
# Select the sound file to be analyzed
# Usage: Opens pop-up window for the user to select the sound file they want to analyze
# Input: WAVE/WAV file (i.e. .wav)
# Output: path to the sound file, saved as "soundfile" in R
soundfile <- file.choose()
setwd(filePath)
source("functions_R.R")
# STEP 1 - PACKAGES
# Loads required packages
loadPackages()
# STEP 2 - SET WORKING DIRECTORY
# CHANGE the 'filePath' value to the directory appropriate to your computer.
# All files in this program will be saved in the folder "R_working_files" within this directory.
# "R_working_files" is a directory pre-made in MAESTRO.
organizeDirectory(filePath)
# STEP 4 - STEREO CHECK
# Check if the sound file is stereo
# The later functions can only use mono sounds
# Therefore, if the sound is stereo, a message will appear and a new sound file will be generated saving only the LEFT channel
# Input: The soundfile path
# Output: If soundfile is mono, soundfileActive is the same file. If soundfile is stereo, a new WAVE file is generated, saved as soundfileMonoL.wav, to which soundActive is saved to.
soundfileStereoCheck(soundfile)
#soundfileSampleRateCheck(soundfileActiveRead)
# STEP 5 - ANALYSIS PARAMETERS
# Here the resolution of ferquency in the analysis can be changed.
# The more frequency bins used, the greater the resolution.
# HOWEVER, the more frequency bins used, the less time bins used (i.e. worsened resolution in the time domain).
# 256*4 (1024) frequency bins appears to be a good number for general use.
# Input: In the line "numberOfFreqBins <- 256*4", change the multiplier (i.e. 4) to the desired amount.
# Output: wlValue will be used in following functions. freqBinWidth gives the frequency range of each bin.
freqParameters(frequencyResolution)
# Input: Nothing on the user's end. All values are generated from the previous functions.
# Output: soundfileDuration gives the duration of the sound file in seconds. timeBinWidth gives the width of each time bin in seconds. numberOfTimeBins gives the number of time bins that will be created by the software.
timeParameters(soundfileActiveRead)
# Input: The wlValue calculated previously and the active soundfile path (designated in STEP 4).
# Output: A visual overview of the time envelope and frequency spectrum of the soundfileActive.
acoustat(soundfileActiveRead, wl = wlValue)
# STEP 6 - EXTRACT FREQUENCYxTIME DATA
# The following function will create the data table that shows the changing intensity values of frequencies over time.
# Everything below the threshold value will be erased to reduce noise.
soundAnalysis(file=soundfileActive, wl = wlValue, thresholdValue = thresholdValue)
# STEP 7 - ISOLATE HARMONICS
# Top-down method: User selects number of harmonics and the fundamental
# Only the 16 (or specified) number of harmonics are required.
# Input: The numberOfHarmonics and the fundamentalFreq values.
# Outpit: A data table with only the rows of the desired harmonics.
numberOfHarmonics <- 16 # This value can be changed as necessary.
fundamentalFreq <- 261.63 # In Hz. (261.63 ~ middle C (C4))
isolateHarmonics() # Uses many arguments, so currently does not allow changes to arguments for simplicity of use
# Time Warning: This could take a minute or longer depending on the amount of data
# This creates all 16 harmonic arrays
#for(i in 1:numberOfHarmonics) {
#  temp_harmonicMatrixScaled_name = paste("harmonicMatrixScaled", i, "array", sep = ".")
#  temp_harmonicMatrixScaled_values <- paste(as.character(harmonicMatrixScaled[,i]), collapse=",")
#  assign(temp_harmonicMatrixScaled_name, temp_harmonicMatrixScaled_values)
#}
# STEP 8 - PLOT
# Time Warning: This could take a minute or longer depending on the amount of data
# Can only draw one at a time
zoom = 0.68 # 0.65 for printing
plotMAESTRO.2d(zoom=zoom)
plotMAESTRO.3d(zoom=zoom, view.x = -3.5, view.y = -1.5, view.z = 1.5, length.x = 1, length.y = 1, length.z = 1, showTime = TRUE, titleTime = "Time (s)") # Arguments control the 3D camera's angle
filePath <- "~/Dropbox/MAPLE-Lab-Auditory-Exploration-Suite/programs/R"
frequencyResolution <- 4 # 4 is a good value with a frequency resolution of ~20Hz. 5 increases frequency resolution to ~10Hz.
thresholdValue <- 0.1 # Set at 0 all noise is captured; however, in top-down analysis (where the user selects the harmonics), this is not a problem and improves audio synthesis
# STEP 3 - SELECT SOUND
# Select the sound file to be analyzed
# Usage: Opens pop-up window for the user to select the sound file they want to analyze
# Input: WAVE/WAV file (i.e. .wav)
# Output: path to the sound file, saved as "soundfile" in R
soundfile <- file.choose()
setwd(filePath)
source("functions_R.R")
# STEP 1 - PACKAGES
# Loads required packages
loadPackages()
# STEP 2 - SET WORKING DIRECTORY
# CHANGE the 'filePath' value to the directory appropriate to your computer.
# All files in this program will be saved in the folder "R_working_files" within this directory.
# "R_working_files" is a directory pre-made in MAESTRO.
organizeDirectory(filePath)
# STEP 4 - STEREO CHECK
# Check if the sound file is stereo
# The later functions can only use mono sounds
# Therefore, if the sound is stereo, a message will appear and a new sound file will be generated saving only the LEFT channel
# Input: The soundfile path
# Output: If soundfile is mono, soundfileActive is the same file. If soundfile is stereo, a new WAVE file is generated, saved as soundfileMonoL.wav, to which soundActive is saved to.
soundfileStereoCheck(soundfile)
soundfileSampleRateCheck(soundfileActiveRead)
# STEP 5 - ANALYSIS PARAMETERS
# Here the resolution of ferquency in the analysis can be changed.
# The more frequency bins used, the greater the resolution.
# HOWEVER, the more frequency bins used, the less time bins used (i.e. worsened resolution in the time domain).
# 256*4 (1024) frequency bins appears to be a good number for general use.
# Input: In the line "numberOfFreqBins <- 256*4", change the multiplier (i.e. 4) to the desired amount.
# Output: wlValue will be used in following functions. freqBinWidth gives the frequency range of each bin.
freqParameters(frequencyResolution)
# Input: Nothing on the user's end. All values are generated from the previous functions.
# Output: soundfileDuration gives the duration of the sound file in seconds. timeBinWidth gives the width of each time bin in seconds. numberOfTimeBins gives the number of time bins that will be created by the software.
timeParameters(soundfileActiveRead)
# Input: The wlValue calculated previously and the active soundfile path (designated in STEP 4).
# Output: A visual overview of the time envelope and frequency spectrum of the soundfileActive.
acoustat(soundfileActiveRead, wl = wlValue)
# STEP 6 - EXTRACT FREQUENCYxTIME DATA
# The following function will create the data table that shows the changing intensity values of frequencies over time.
# Everything below the threshold value will be erased to reduce noise.
soundAnalysis(file=soundfileActive, wl = wlValue, thresholdValue = thresholdValue)
# STEP 7 - ISOLATE HARMONICS
# Top-down method: User selects number of harmonics and the fundamental
# Only the 16 (or specified) number of harmonics are required.
# Input: The numberOfHarmonics and the fundamentalFreq values.
# Outpit: A data table with only the rows of the desired harmonics.
numberOfHarmonics <- 16 # This value can be changed as necessary.
fundamentalFreq <- 261.63 # In Hz. (261.63 ~ middle C (C4))
isolateHarmonics() # Uses many arguments, so currently does not allow changes to arguments for simplicity of use
# Time Warning: This could take a minute or longer depending on the amount of data
# This creates all 16 harmonic arrays
#for(i in 1:numberOfHarmonics) {
#  temp_harmonicMatrixScaled_name = paste("harmonicMatrixScaled", i, "array", sep = ".")
#  temp_harmonicMatrixScaled_values <- paste(as.character(harmonicMatrixScaled[,i]), collapse=",")
#  assign(temp_harmonicMatrixScaled_name, temp_harmonicMatrixScaled_values)
#}
# STEP 8 - PLOT
# Time Warning: This could take a minute or longer depending on the amount of data
# Can only draw one at a time
zoom = 0.68 # 0.65 for printing
plotMAESTRO.2d(zoom=zoom)
plotMAESTRO.3d(zoom=zoom, view.x = -3.5, view.y = -1.5, view.z = 1.5, length.x = 1, length.y = 1, length.z = 1, showTime = TRUE, titleTime = "Time (s)") # Arguments control the 3D camera's angle
filePath <- "~/Dropbox/MAPLE-Lab-Auditory-Exploration-Suite/programs/R"
frequencyResolution <- 4 # 4 is a good value with a frequency resolution of ~20Hz. 5 increases frequency resolution to ~10Hz.
thresholdValue <- 0.1 # Set at 0 all noise is captured; however, in top-down analysis (where the user selects the harmonics), this is not a problem and improves audio synthesis
# STEP 3 - SELECT SOUND
# Select the sound file to be analyzed
# Usage: Opens pop-up window for the user to select the sound file they want to analyze
# Input: WAVE/WAV file (i.e. .wav)
# Output: path to the sound file, saved as "soundfile" in R
soundfile <- file.choose()
setwd(filePath)
source("functions_R.R")
# STEP 1 - PACKAGES
# Loads required packages
loadPackages()
# STEP 2 - SET WORKING DIRECTORY
# CHANGE the 'filePath' value to the directory appropriate to your computer.
# All files in this program will be saved in the folder "R_working_files" within this directory.
# "R_working_files" is a directory pre-made in MAESTRO.
organizeDirectory(filePath)
# STEP 4 - STEREO CHECK
# Check if the sound file is stereo
# The later functions can only use mono sounds
# Therefore, if the sound is stereo, a message will appear and a new sound file will be generated saving only the LEFT channel
# Input: The soundfile path
# Output: If soundfile is mono, soundfileActive is the same file. If soundfile is stereo, a new WAVE file is generated, saved as soundfileMonoL.wav, to which soundActive is saved to.
soundfileStereoCheck(soundfile)
soundfileSampleRateCheck(soundfileActiveRead)
# STEP 5 - ANALYSIS PARAMETERS
# Here the resolution of ferquency in the analysis can be changed.
# The more frequency bins used, the greater the resolution.
# HOWEVER, the more frequency bins used, the less time bins used (i.e. worsened resolution in the time domain).
# 256*4 (1024) frequency bins appears to be a good number for general use.
# Input: In the line "numberOfFreqBins <- 256*4", change the multiplier (i.e. 4) to the desired amount.
# Output: wlValue will be used in following functions. freqBinWidth gives the frequency range of each bin.
freqParameters(frequencyResolution)
# Input: Nothing on the user's end. All values are generated from the previous functions.
# Output: soundfileDuration gives the duration of the sound file in seconds. timeBinWidth gives the width of each time bin in seconds. numberOfTimeBins gives the number of time bins that will be created by the software.
timeParameters(soundfileActiveRead)
# Input: The wlValue calculated previously and the active soundfile path (designated in STEP 4).
# Output: A visual overview of the time envelope and frequency spectrum of the soundfileActive.
acoustat(soundfileActiveRead, wl = wlValue)
# STEP 6 - EXTRACT FREQUENCYxTIME DATA
# The following function will create the data table that shows the changing intensity values of frequencies over time.
# Everything below the threshold value will be erased to reduce noise.
soundAnalysis(file=soundfileActive, wl = wlValue, thresholdValue = thresholdValue)
# STEP 7 - ISOLATE HARMONICS
# Top-down method: User selects number of harmonics and the fundamental
# Only the 16 (or specified) number of harmonics are required.
# Input: The numberOfHarmonics and the fundamentalFreq values.
# Outpit: A data table with only the rows of the desired harmonics.
numberOfHarmonics <- 16 # This value can be changed as necessary.
fundamentalFreq <- 261.63 # In Hz. (261.63 ~ middle C (C4))
isolateHarmonics() # Uses many arguments, so currently does not allow changes to arguments for simplicity of use
# Time Warning: This could take a minute or longer depending on the amount of data
# This creates all 16 harmonic arrays
#for(i in 1:numberOfHarmonics) {
#  temp_harmonicMatrixScaled_name = paste("harmonicMatrixScaled", i, "array", sep = ".")
#  temp_harmonicMatrixScaled_values <- paste(as.character(harmonicMatrixScaled[,i]), collapse=",")
#  assign(temp_harmonicMatrixScaled_name, temp_harmonicMatrixScaled_values)
#}
# STEP 8 - PLOT
# Time Warning: This could take a minute or longer depending on the amount of data
# Can only draw one at a time
zoom = 0.68 # 0.65 for printing
plotMAESTRO.2d(zoom=zoom)
plotMAESTRO.3d(zoom=zoom, view.x = -3.5, view.y = -1.5, view.z = 1.5, length.x = 1, length.y = 1, length.z = 1, showTime = TRUE, titleTime = "Time (s)") # Arguments control the 3D camera's angle
?savewav
soundfileActiveRead
audioSample(soundfileActiveRead, rate=44100)
audioSample(soundfileActive, rate=44100)
soundfileActive
save.wave(audioSample(soundfileActive, rate=44100), "/Users/max/Dropbox/MAPLE-Lab-Auditory-Exploration-Suite/programs/R/R_working_files/soundfileMonoL2.wav")
save.wave
?save.wave
audioSample(soundfileActive, rate=44100)
save.wave(audioSample(soundfileActive, rate=44100), "/Users/max/Dropbox/MAPLE-Lab-Auditory-Exploration-Suite/programs/R/R_working_files/")
save.wave(audioSample(soundfileActive, rate=44100), "wavetest.wav")
?writeWave
