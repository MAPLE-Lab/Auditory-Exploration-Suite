emodata_final <- read.delim("~/Documents/emodata_final.txt")
View(emodata_final)
fit_valence<-lm(Valence.response~ Tempo.mir + Pitch.mir + Mode.mir, data=emodata_final)
fit_arousal<-lm(Arousal.response~ Tempo.mir + Pitch.mir + Mode.mir, data=emodata_final)
summary(fit_valence)
summary(fit_arousal)
cor.test(dataframe$Valence.response,dataframe$Valence.response/Tempo.mir)
cor.test(emodata_final$Valence.response,emodata_final$Valence.response/Tempo.mir)
cor.test(data=emodata_final$Valence.response,data=emodata_final$Valence.response/Tempo.mir)
cor.test(emodata_final$Valence.response,emodata_final$Valence.response/Tempo.mir)
cor.test(emodata_final$Valence.response,emodata_final$Tempo.mir)
cor.test(emodata_final$Valence.response,emodata_final$Pitch.mir)
cor.test(emodata_final$Valence.response,emodata_final$Mode.mir)
cor.test(emodata_final$Arousal.response,emodata_final$Tempo.mir)
cor.test(emodata_final$Arousal.response,emodata_final$Pitch.mir)
cor.test(emodata_final$Arousal.response,emodata_final$Mode.mir)
seewave
help seewave
install.packages(c("fftw","tuneR","rgl","rpanel"), repos="http://cran.at.r-project.org/")
?stft.ext
{}
file=
data(tico)
library("seewave", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
seewave
?seewave
stft.ext
?stft.ext
demo(seewave)
waver <- file="AltoSax.vib.ff.Db3.stereo.aif"
waver
savewav(waver, file="AltoSax.vib.ff.Db3.stereo.aif")
data(waver)
a <- 5
a
waver <- 5
waver
data(waver)
stft.ext(file="AltoSax.vib.ff.Db3.stereo.aif")
save.image("~/Documents/test_r.RData")
stft.ext(file="AltoSax.vib.ff.Db3.stereo.aif")
load("~/Documents/AltoSax.vib.ff.Db3.stereo.aif")
?data
?file
file(open = "AltoSax.vib.ff.Db3.stereo.aif")
file="AltoSax.vib.ff.Db3.stereo.aif"
?seewave
?stft.ext
tuning_fork_A4.wav
"tuning_fork_A4.wav"
file="tuning_fork_A4.wav"
stft.ext(file="tuning_fork_A4.wav")
library(seewave)
library(tuneR)
a <- readWave("mysound.wav")
a <- readWave("tuning_fork_A4.wav")
getwd()
a <- readWave("Documents/tuning_fork_A4.wav")
a
stft.ext(file="Documents/tuning_fork_A4.wav")
?stft.ext
stft.ext(file="Documents/tuning_fork_A4.wav")
data(a)
a
savewav(waver, file="Documents/tuning_fork_A4.wav")
stft.ext("Documents/tuning_fork_A4.wav", db = TRUE)
stft.ext("Documents/tuning_fork_A4.wav", dB = TRUE)
b <- stft.ext("Documents/tuning_fork_A4.wav", db = TRUE)
b <- stft.ext("Documents/tuning_fork_A4.wav", dB = TRUE)
View(b)
c <- stft.ext("Documents/tuning_fork_A4.wav")
View(c)
View(c)
write.csv(c, file=waver.csv)
write.csv(spectra,file=c)
write.csv(c,file=wave.csv)
?write.csv
?stft
?stft.ext
fftw
?fftw
seedata(c)
seedata(c)
seedata(c)
View(c)
View(c)
?write.csv
write.csv(c, "c_data.csv")
frequency
f <- 44100
f/364
plotly
install.packages("plotly")
library("plotly", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library(plotly)
p <- plot_ly(midwest, x = ~percollege, color = ~state, type = "box")
p
library(plotly)
p <- plot_ly(midwest, x = ~percollege, color = ~state, type = "box")
p
?plotly
set.seed(100)
d <- diamonds[sample(nrow(diamonds), 1000), ]
plot_ly(d, x = ~carat, y = ~price, color = ~carat,
size = ~carat, text = ~paste("Clarity: ", clarity))
plot_ly(d, x = ~carat, y = ~price, color = ~carat, size = ~carat, text = ~paste("Clarity: ", clarity))
library("lazyeval")
plot_ly(d, x = ~carat, y = ~price, color = ~carat, size = ~carat, text = ~paste("Clarity: ", clarity))
detach("package:plotly", unload=TRUE)
library("plotly", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library("lazyeval")
library(plotly)
set.seed(100)
d <- diamonds[sample(nrow(diamonds), 1000), ]
plot_ly(d, x = ~carat, y = ~price, color = ~carat,
size = ~carat, text = ~paste("Clarity: ", clarity))
download.file("http://rug.mnhn.fr/seewave/WAV/E_chopardi_whistle.wav", destfile="cock.wav")
cock<-readWAve("cock.wav")
spectro3D(cock, f=22050, wl=490, ovlp=85, zp=6, maga=4, palette=spectro.colors)
rgl.viewpoint(-90,0)
step1 <- seq(-90,271,by=4)
for (i in step1){
rgl.viewpoint(i,(i/4.5)+30)
filename <- paste("picA",which(step1==i),".png",sep="")
rgl.snapshot(filename)
}
rgl.viewpoint(270,90)
step <- seq(270,-90,by=-4)
for (i in step2){
rgl.viewpoint(i,(i/4.5)+30)
filename <- paste("picB",which(step2==i),".png",sep="")
rgl.snapshot(filename)}
library("lazyeval")
library(plotly)
library(seewave)
download.file("http://rug.mnhn.fr/seewave/WAV/E_chopardi_whistle.wav", destfile="cock.wav")
cock<-readWAve("cock.wav")
spectro3D(cock, f=22050, wl=490, ovlp=85, zp=6, maga=4, palette=spectro.colors)
rgl.viewpoint(-90,0)
step1 <- seq(-90,271,by=4)
for (i in step1){
rgl.viewpoint(i,(i/4.5)+30)
filename <- paste("picA",which(step1==i),".png",sep="")
rgl.snapshot(filename)
}
rgl.viewpoint(270,90)
step <- seq(270,-90,by=-4)
for (i in step2){
rgl.viewpoint(i,(i/4.5)+30)
filename <- paste("picB",which(step2==i),".png",sep="")
rgl.snapshot(filename)}
download.file("http://rug.mnhn.fr/seewave/WAV/E_chopardi_whistle.wav", destfile="cock.wav")
cock<-readWAve("cock.wav")
?readWave
cock<-readWave("cock.wav")
ReadWave
library("tuneR", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
cock<-readWAve("cock.wav")
?readWave
readWave()
cock<-readWAve("cock.wav")
readWave("cock.wav")
cock <- readWAve("cock.wav")
cock<-readWave("cock.wav")
spectro3D(cock, f=22050, wl=490, ovlp=85, zp=6, maga=4, palette=spectro.colors)
spectro3D
?spectro3D
spectro3D(cock, f=22050, wl=490, ovlp=85, zp=6, maga=4, palette=spectro.colors)
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
?rgl
?"seewave"
?"seewave"
?"rgl"
??rgl
??rgl
install.packages("~/Downloads/rgl_0.98.1.tgz.cpgz", repos = NULL)
install.packages("~/Dropbox/local-SuperCollider/rgl_0.98.1.tgz", repos = NULL, type = .Platform$pkgType)
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
detach("package:rgl", unload=TRUE)
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
detach("package:rgl", unload=TRUE)
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
install.packages("rgl", lib="Desktop/rgl_0.96.0 (1).tgz")
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library(plotly)
dens <- with(diamonds, tapply(price, INDEX = cut, density))
data <- data.frame(
x = unlist(lapply(dens, "[[", "x")),
y = unlist(lapply(dens, "[[", "y")),
cut = rep(names(dens), each = length(dens[[1]]$x)))
p <- plot_ly(data, x = ~x, y = ~cut, z = ~y, type = 'scatter3d', mode = 'lines', color = ~cut)
p
View(data)
plot_ly()
plot_ly(x = 1:10, y = 1:10)
d <- diamonds[sample(nrow(diamonds), 1000), ]
plot_ly(d, x = ~carat, y = ~price, text = ~paste("Clarity: ", clarity),
mode = "markers", color = ~carat, size = ~carat, marker = list(line = list(color = "black")))
library(plotly)
dens <- with(diamonds, tapply(price, INDEX = cut, density))
data <- data.frame(
x = unlist(lapply(dens, "[[", "x")),
y = unlist(lapply(dens, "[[", "y")),
cut = rep(names(dens), each = length(dens[[1]]$x)))
p <- plot_ly(data, x = ~x, y = ~cut, z = ~y, type = 'scatter3d', mode = 'lines', color = ~cut)
p
# Welcome to the R program to created data tables for MAESTRO (SuperCollider component)!
# STEP 0 - SOURCE FUNCTIONS
# This line loads all the functions from the "functions_R.R" R code file.
# These functions are then called (with appropriate arguments) in all following code.
filePath <- "~/Dropbox/MAPLE-Lab-Auditory-Exploration-Suite/programs/R"
frequencyResolution <- 4 # 4 is a good value with a frequency resolution of ~20Hz. 5 increases frequency resolution to ~10Hz.
thresholdValue <- 0 # Set at 0 all noise is captured; however, in top-down analysis (where the user selects the harmonics), this is not a problem and improves audio synthesis
# STEP 3 - SELECT SOUND
# Select the sound file to be analyzed
# Usage: Opens pop-up window for the user to select the sound file they want to analyze
# Input: WAVE/WAV file (i.e. .wav)
# Output: path to the sound file, saved as "soundfile" in R
soundfile <- file.choose()
setwd(filePath)
source("functions_R.R")
# STEP 1 - PACKAGES
# Loads required packages
loadPackages()
# STEP 2 - SET WORKING DIRECTORY
# CHANGE the 'filePath' value to the directory appropriate to your computer.
# All files in this program will be saved in the folder "R_working_files" within this directory.
# "R_working_files" is a directory pre-made in MAESTRO.
organizeDirectory(filePath)
# STEP 4 - STEREO CHECK
# Check if the sound file is stereo
# The later functions can only use mono sounds
# Therefore, if the sound is stereo, a message will appear and a new sound file will be generated saving only the LEFT channel
# Input: The soundfile path
# Output: If soundfile is mono, soundfileActive is the same file. If soundfile is stereo, a new WAVE file is generated, saved as soundfileMonoL.wav, to which soundActive is saved to.
soundfileStereoCheck(soundfile)
# STEP 5 - ANALYSIS PARAMETERS
# Here the resolution of ferquency in the analysis can be changed.
# The more frequency bins used, the greater the resolution.
# HOWEVER, the more frequency bins used, the less time bins used (i.e. worsened resolution in the time domain).
# 256*4 (1024) frequency bins appears to be a good number for general use.
# Input: In the line "numberOfFreqBins <- 256*4", change the multiplier (i.e. 4) to the desired amount.
# Output: wlValue will be used in following functions. freqBinWidth gives the frequency range of each bin.
freqParameters(frequencyResolution)
# Input: Nothing on the user's end. All values are generated from the previous functions.
# Output: soundfileDuration gives the duration of the sound file in seconds. timeBinWidth gives the width of each time bin in seconds. numberOfTimeBins gives the number of time bins that will be created by the software.
timeParameters(soundfileActiveRead)
# Input: The wlValue calculated previously and the active soundfile path (designated in STEP 4).
# Output: A visual overview of the time envelope and frequency spectrum of the soundfileActive.
acoustat(soundfileActiveRead, wl = wlValue)
# STEP 6 - EXTRACT FREQUENCYxTIME DATA
# The following function will create the data table that shows the changing intensity values of frequencies over time.
# Everything below the threshold value will be erased to reduce noise.
soundAnalysis(file=soundfileActive, wl = wlValue, thresholdValue = thresholdValue)
# STEP 7 - ISOLATE HARMONICS
# Top-down method: User selects number of harmonics and the fundamental
# Only the 16 (or specified) number of harmonics are required.
# Input: The numberOfHarmonics and the fundamentalFreq values.
# Outpit: A data table with only the rows of the desired harmonics.
numberOfHarmonics <- 16 # This value can be changed as necessary.
fundamentalFreq <- 261.63 # In Hz.
isolateHarmonics() # Uses many arguments, so currently does not allow changes to arguments for simplicity of use
# This creates all 16 harmonic arrays
#for(i in 1:numberOfHarmonics) {
#  temp_harmonicMatrixScaled_name = paste("harmonicMatrixScaled", i, "array", sep = ".")
#  temp_harmonicMatrixScaled_values <- paste(as.character(harmonicMatrixScaled[,i]), collapse=",")
#  assign(temp_harmonicMatrixScaled_name, temp_harmonicMatrixScaled_values)
#}
# STEP 8 - PLOT
plotMAESTRO()
test_bind <- rbind(plotsHarmonicData.1, plotsHarmonicData.2, plotsHarmonicData.3, plotsHarmonicData.4, plotsHarmonicData.5, plotsHarmonicData.6, plotsHarmonicData.7, plotsHarmonicData.8, plotsHarmonicData.9, plotsHarmonicData.10)
p <- plot_ly(test_bind, x = ~time, y = ~harmonic, z = ~intensity, type = 'scatter3d', mode = 'lines', color = ~harmonic)
p
test_bind <- rbind(plotsHarmonicData.1, plotsHarmonicData.2, plotsHarmonicData.3, plotsHarmonicData.4, plotsHarmonicData.5, plotsHarmonicData.6, plotsHarmonicData.7, plotsHarmonicData.8, plotsHarmonicData.9, plotsHarmonicData.10)
plotMAESTRO <- function() {
# List the length of the harmonicMatrixScaled to allow the name to be repeated
harmonicDataframeLengthSeq = seq(1:nrow(harmonicMatrixScaled))
# FOR Loop to process all harmonics, creates data frame of the form:
# "time"  "intensity" "harmonic"
# Name of files are of the form "plotsHarmonicData.i" where i = 1:numberOfHarmonics
for(i in 1:numberOfHarmonics) {
#print(i)
temp_plot_dataframe <- data.frame(
intensity=c(harmonicMatrixScaled[,i])
)
temp_name_list <- rep(as.character(i), length(harmonicDataframeLengthSeq)) # plot_ly does not work if the names are not CHARACTERS
#print(temp_name_list)
temp_time_intensity_harmonic <- cbind(rownames(harmonicMatrixScaled), temp_plot_dataframe, temp_name_list)
colnames(temp_time_intensity_harmonic) <- c("time", "intensity", "harmonic")
temp_plot_dataframe_name <- paste("plotsHarmonicData", i, sep = ".")
assign(temp_plot_dataframe_name, temp_time_intensity_harmonic)
}
# Combine all the data
for(i in 2:numberOfHarmonics) {
plotsHarmonicData.1 # Known at minimum there is the 1st harmonic used
temp_lister_name <- paste0("plotsHarmonicData.", i)
if(i == 2) {
temp_total_names <- paste("plotsHarmonicData.1,",temp_lister_name)   # Clears any old data automatically as well
} else {
print(i)
print(temp_total_names)
temp_total_names <- paste(temp_total_names, temp_lister_name, sep = ",")
print(temp_total_names)
print("Next step:")
}
}
test_bind <- rbind(plotsHarmonicData.1, plotsHarmonicData.2, plotsHarmonicData.3, plotsHarmonicData.4, plotsHarmonicData.5, plotsHarmonicData.6, plotsHarmonicData.7, plotsHarmonicData.8, plotsHarmonicData.9, plotsHarmonicData.10)
test_bind2 <- rbind(as.symbol(temp_total_names))
# Use the combined data for the plot
p <- plot_ly(test_bind, x = ~time, y = ~harmonic, z = ~intensity, type = 'scatter3d', mode = 'lines', color = ~harmonic)
p
}
plotMAESTRO()
fundamentalFreq
freqBinWidth
fundamentalFreq / freqBinWidth
isolateHarmonics <- function() {
harmonicSeq <- seq(from = fundamentalFreq, to = fundamentalFreq*numberOfHarmonics, by = fundamentalFreq)
# Every row is the same frequency distance from the next = freqBinWidth
startingBin <- as.integer(fundamentalFreq / freqBinWidth + 1) # +1 added to round up as it is needed for optimal results, based on trial and error
harmonicColSeq <- seq(from = startingBin, to = startingBin*numberOfHarmonics, by = (fundamentalFreq / freqBinWidth)) # Based on horn and cello values
soundMatrixThresholdNamedTransposed <- t(soundMatrixThresholdNamed)
harmonicMatrix <- soundMatrixThresholdNamedTransposed[,harmonicColSeq[1:numberOfHarmonics]]
maximumValue <- max(harmonicMatrix, na.rm = TRUE)
scaleFunction <- (function(x) x/maximumValue)
harmonicMatrixScaled <- harmonicMatrix # Creates a duplicate matrix
harmonicMatrixScaled[] <- vapply(harmonicMatrix, scaleFunction, numeric(1)) # Scales all values to be between 0-1.
harmonicMatrixScaled <<- harmonicMatrixScaled
}
isolateHarmonics() # Uses many arguments, so currently does not allow changes to arguments for simplicity of use
# This creates all 16 harmonic arrays
#for(i in 1:numberOfHarmonics) {
#  temp_harmonicMatrixScaled_name = paste("harmonicMatrixScaled", i, "array", sep = ".")
#  temp_harmonicMatrixScaled_values <- paste(as.character(harmonicMatrixScaled[,i]), collapse=",")
#  assign(temp_harmonicMatrixScaled_name, temp_harmonicMatrixScaled_values)
#}
# STEP 8 - PLOT
plotMAESTRO()
View(soundMatrixThresholdNamed)
View(harmonicMatrixScaled)
View(data)
soundfileDuration
numberOfTimeBins
timeBinWidth <<- soundfileDuration/numberOfTimeBins
timeBinWidth
timeBinWidth*numberOfTimeBins
timeParameters <- function(x) { # Input argument: soundfileActiveRead
soundfileDuration <<- (length(x@left)/x@samp.rate) # The sound should be mono so @left and @right should not matter
numberOfTimeBins <<- round(soundfileDuration/timeBinWidth-0.5) # The -0.5 rounds the number down, as the later functions will do (it seems).
timeBinWidth <<- soundfileDuration/numberOfTimeBins
#timeBinWidth <<- (2.98/64)/(1024/numberOfFreqBins) # ERROR: SOMETIMES NEEDS TO BE x2 THIS VALUE, UNKNOWN CAUSE AS OF June 11, 2017
}
source("functions_R.R")
timeParameters(soundfileActiveRead)
# Input: The wlValue calculated previously and the active soundfile path (designated in STEP 4).
# Output: A visual overview of the time envelope and frequency spectrum of the soundfileActive.
acoustat(soundfileActiveRead, wl = wlValue)
# STEP 6 - EXTRACT FREQUENCYxTIME DATA
# The following function will create the data table that shows the changing intensity values of frequencies over time.
# Everything below the threshold value will be erased to reduce noise.
soundAnalysis(file=soundfileActive, wl = wlValue, thresholdValue = thresholdValue)
# STEP 7 - ISOLATE HARMONICS
# Top-down method: User selects number of harmonics and the fundamental
# Only the 16 (or specified) number of harmonics are required.
# Input: The numberOfHarmonics and the fundamentalFreq values.
# Outpit: A data table with only the rows of the desired harmonics.
numberOfHarmonics <- 16 # This value can be changed as necessary.
fundamentalFreq <- 261.63 # In Hz.
isolateHarmonics() # Uses many arguments, so currently does not allow changes to arguments for simplicity of use
# This creates all 16 harmonic arrays
#for(i in 1:numberOfHarmonics) {
#  temp_harmonicMatrixScaled_name = paste("harmonicMatrixScaled", i, "array", sep = ".")
#  temp_harmonicMatrixScaled_values <- paste(as.character(harmonicMatrixScaled[,i]), collapse=",")
#  assign(temp_harmonicMatrixScaled_name, temp_harmonicMatrixScaled_values)
#}
# STEP 8 - PLOT
plotMAESTRO()
View(harmonicMatrixScaled)
soundfileDuration
timeBinWidth
soundfileDuration <<- (length(x@left)/x@samp.rate) # The sound should be mono so @left and @right should not matter
approxtimeBinWidth <<- (2.98/64)/(1024/numberOfFreqBins) # ERROR: SOMETIMES NEEDS TO BE x2 THIS VALUE, UNKNOWN CAUSE AS OF June 11, 2017
soundfileDuration <<- (length(soundfileActiveRead@left)/soundfileActiveRead@samp.rate) # The sound should be mono so @left and @right should not matter
approxtimeBinWidth <<- (2.98/64)/(1024/numberOfFreqBins) # ERROR: SOMETIMES NEEDS TO BE x2 THIS VALUE, UNKNOWN CAUSE AS OF June 11, 2017
numberOfTimeBins <<- round(soundfileDuration/approxtimeBinWidth-0.5) # The -0.5 rounds the number down, as the later functions will do (it seems).
timeBinWidth <<- soundfileDuration/numberOfTimeBins # This new version calculates based on reasonable/logical statistics, unlike previous version below
}
test_bind2 <- rbind(as.symbol(temp_total_names))
# List the length of the harmonicMatrixScaled to allow the name to be repeated
harmonicDataframeLengthSeq = seq(1:nrow(harmonicMatrixScaled))
# FOR Loop to process all harmonics, creates data frame of the form:
# "time"  "intensity" "harmonic"
# Name of files are of the form "plotsHarmonicData.i" where i = 1:numberOfHarmonics
for(i in 1:numberOfHarmonics) {
#print(i)
temp_plot_dataframe <- data.frame(
intensity=c(harmonicMatrixScaled[,i])
)
temp_name_list <- rep(as.character(i), length(harmonicDataframeLengthSeq)) # plot_ly does not work if the names are not CHARACTERS
#print(temp_name_list)
temp_time_intensity_harmonic <- cbind(rownames(harmonicMatrixScaled), temp_plot_dataframe, temp_name_list)
colnames(temp_time_intensity_harmonic) <- c("time", "intensity", "harmonic")
temp_plot_dataframe_name <- paste("plotsHarmonicData", i, sep = ".")
assign(temp_plot_dataframe_name, temp_time_intensity_harmonic)
}
# Combine all the data
for(i in 2:numberOfHarmonics) {
plotsHarmonicData.1 # Known at minimum there is the 1st harmonic used
temp_lister_name <- paste0("plotsHarmonicData.", i)
if(i == 2) {
temp_total_names <- paste("plotsHarmonicData.1,",temp_lister_name)   # Clears any old data automatically as well
} else {
print(i)
print(temp_total_names)
temp_total_names <- paste(temp_total_names, temp_lister_name, sep = ",")
print(temp_total_names)
print("Next step:")
}
}
test_bind2 <- rbind(as.symbol(temp_total_names))
test_bind2 <- rbind(as.character(temp_total_names))
test_bind2
# Combine all the data
for(i in 2:numberOfHarmonics) {
plotsHarmonicData.1 # Known at minimum there is the 1st harmonic used
temp_lister_name <- paste0("plotsHarmonicData.", i)
if(i == 2) {
temp_total_names <- paste("plotsHarmonicData.1,",temp_lister_name)   # Clears any old data automatically as well
} else {
print(i)
print(temp_total_names)
temp_total_names <- paste(temp_total_names, temp_lister_name, sep = ", ")
print(temp_total_names)
print("Next step:")
}
}
test_bind2 <- rbind(as.character(temp_total_names))
test_bind2
test_bind2
rbind(as.character(temp_total_names))
rbind(as.character(temp_total_names))
test_bind2 <- rbind(eval(partse(temp_total_names)))
test_bind2 <- rbind(eval(parse(temp_total_names)))
test_bind2 <- rbind(eval(parse(as.character(temp_total_names)))
parse(as.character(temp_total_names))
parse(as.character(temp_total_names))
test_bind2 <- rbind(eval(parse(as.character(temp_total_names))
test_bind2 <- rbind(eval(parse(as.character(temp_total_names))))
?parse
eval(parse(plotsHarmonicData.1))
eval(parse(as.character(plotsHarmonicData.1))
)
test_bind2 <- rbind(temp_total_names)
test_bind2
test_bind <- rbind(plotsHarmonicData.1,
plotsHarmonicData.2, plotsHarmonicData.3, plotsHarmonicData.4, plotsHarmonicData.5, plotsHarmonicData.6, plotsHarmonicData.7, plotsHarmonicData.8, plotsHarmonicData.9, plotsHarmonicData.10)
test_bind <- rbind(plotsHarmonicData.1, plotsHarmonicData.2, plotsHarmonicData.3, plotsHarmonicData.4, plotsHarmonicData.5, plotsHarmonicData.6, plotsHarmonicData.7, plotsHarmonicData.8, plotsHarmonicData.9, plotsHarmonicData.17)
test_bind
test_bind <- rbind(plotsHarmonicData.1, plotsHarmonicData.2, plotsHarmonicData.3, plotsHarmonicData.4, plotsHarmonicData.5, plotsHarmonicData.6, plotsHarmonicData.7, plotsHarmonicData.8, plotsHarmonicData.9, plotsHarmonicData.17)
test_bind <- rbind(plotsHarmonicData.1, plotsHarmonicData.2, plotsHarmonicData.3, plotsHarmonicData.4, plotsHarmonicData.5, plotsHarmonicData.6, plotsHarmonicData.7, plotsHarmonicData.8, plotsHarmonicData.9, plotsHarmonicData.10)
paste0("rbind(", temp_total_names, ")")
eval(parse(paste0("rbind(", temp_total_names, ")")))
class(parse(paste0("rbind(", temp_total_names, ")")))
paste0("rbind(", temp_total_names, ")")
parse(text=paste0("rbind(", temp_total_names, ")"))
class(parse(text=paste0("rbind(", temp_total_names, ")")))
eval(parse(text=paste0("rbind(", temp_total_names, ")")))
test_bind <- eval(parse(text=paste0("rbind(", temp_total_names, ")")))
test_bind
p <- plot_ly(test_bind, x = ~time, y = ~harmonic, z = ~intensity, type = 'scatter3d', mode = 'lines', color = ~harmonic)
p
p <- plot_ly(test_bind, x = ~time, y = ~harmonic, z = ~intensity, type = 'scatter3d', mode = 'lines')
p
p <- plot_ly(test_bind, x = ~time, y = ~harmonic, z = ~intensity, type = 'scatter3d', mode = 'lines', color = ~harmonic)
p
